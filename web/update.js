// Generated by CoffeeScript 1.4.0

/*
Copyright 2014 Rafael Gieschke

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


(function() {
  var Buffer, PdfDict, PdfObjectManager, PdfWriter, genObjId, getBlob, group, isArray, isDict, isRef, pad, serialize, toHex, values;

  Buffer = function(size) {
    if (size == null) {
      size = 1024;
    }
    this.array = new Uint8Array(size);
    return this.length = 0;
  };

  Buffer.prototype = {
    ensureAvailable: function(length) {
      var arrayNew, neededSize, newSize;
      neededSize = this.length + length;
      newSize = this.array.byteLength;
      if (neededSize <= newSize) {
        return;
      }
      while (neededSize > newSize) {
        newSize *= 2;
      }
      arrayNew = new Uint8Array(newSize);
      arrayNew.set(this.getArray(), 0);
      this.array = arrayNew;
    },
    writeArray: function(array) {
      if (array instanceof Buffer) {
        array = array.getArray();
      }
      this.ensureAvailable(array.byteLength);
      this.array.set(array, this.length);
      this.length += array.byteLength;
    },
    writeNumBigEndian: function(num, numBytes) {
      var i, _i, _ref;
      if (numBytes == null) {
        numBytes = 1;
      }
      if (numBytes * 8 > 32) {
        throw new Error("NumBytes is too large.");
      }
      if (num < 0) {
        throw new Error("Num must not be negative.");
      }
      if (num > Math.pow(2, numBytes * 8) - 1) {
        throw new Error("Num is too large.");
      }
      this.ensureAvailable(numBytes);
      for (i = _i = _ref = numBytes - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
        this.array[this.length++] = (num >>> i * 8) & 0xff;
      }
    },
    writeStringLatin1: function(str) {
      var i, _, _i, _len;
      this.ensureAvailable(str.length);
      for (i = _i = 0, _len = str.length; _i < _len; i = ++_i) {
        _ = str[i];
        this.array[this.length++] = str.charCodeAt(i);
      }
    },
    getByteLength: function() {
      return this.length;
    },
    getArray: function() {
      return this.array.subarray(0, this.length);
    }
  };

  values = function(obj) {
    var v, _, _results;
    _results = [];
    for (_ in obj) {
      v = obj[_];
      _results.push(v);
    }
    return _results;
  };

  group = function(constArray, sortFunc, groupFunc) {
    var array, curGroup, groups, v, _i, _len;
    array = constArray.slice(0);
    array.sort(sortFunc);
    if (array.length === 0) {
      return [];
    }
    groups = [];
    curGroup = [array.shift()];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      v = array[_i];
      if (groupFunc(v, curGroup)) {
        curGroup.push(v);
      } else {
        groups.push(curGroup);
        curGroup = [v];
      }
    }
    groups.push(curGroup);
    return groups;
  };

  pad = function(num, length) {
    var str;
    str = "" + num;
    while (str.length < length) {
      str = "0" + str;
    }
    return str;
  };

  toHex = function(str) {
    var i, _;
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (i = _i = 0, _len = str.length; _i < _len; i = ++_i) {
        _ = str[i];
        _results.push(pad(str.charCodeAt(i).toString(16), 2));
      }
      return _results;
    })()).join("");
  };

  isDict = function(obj) {
    return (typeof obj === "object") && ("map" in obj) && !isArray(obj);
  };

  isArray = function(obj) {
    return (typeof obj === "object") && (obj instanceof Array);
  };

  isRef = function(obj) {
    return (typeof obj === "object") && ("num" in obj);
  };

  genObjId = function(ref) {
    return "R" + ref.num + "." + ref.gen;
  };

  PdfObjectManager = function() {
    this.objects = {};
    this.dirty = {};
    this.pdfWriter = new PdfWriter();
    this.basePdfDocument = null;
  };

  PdfObjectManager.prototype = {
    setBaseDocumentPromise: function(basePdfDocument) {
      var _this = this;
      this.basePdfDocument = basePdfDocument;
      return this.basePdfDocument.getDownloadInfo().then(function(info) {
        _this.pdfWriter.globalOffset = info.length;
        return _this.getTrailerPromise();
      }).then(function(trailer) {
        _this.pdfWriter.trailer = trailer;
        _this.pdfWriter.nextNum = trailer.map.Size;
        _this.pdfWriter.trailer.map.Prev = _this.basePdfDocument.pdfInfo.startXRef;
      });
    },
    writeUpdated: function() {
      var v, _, _ref;
      _ref = this.dirty;
      for (_ in _ref) {
        v = _ref[_];
        this.pdfWriter.writeObj(v.ref, v.val);
      }
      this.dirty = {};
      return this;
    },
    update: function(ref, val) {
      var id;
      id = genObjId(ref);
      this.objects[id] = val;
      this.dirty[id] = {
        ref: ref,
        val: val
      };
      return this;
    },
    getTrailerPromise: function() {
      return this.getPromise("trailer");
    },
    getPromise: function(ref) {
      var objId,
        _this = this;
      objId = genObjId(ref);
      if (objId in this.objects) {
        return Promise.resolve(this.objects[objId]);
      }
      return this.basePdfDocument.transport.getRawObject(ref).then(function(obj) {
        if (objId in _this.objects) {
          return _this.objects[objId];
        }
        if (isDict(obj)) {
          obj = new PdfDict(obj, null, ref, _this);
        }
        _this.objects[objId] = obj;
        return obj;
      });
    },
    createObjectURLPromise: function() {
      var _this = this;
      this.writeUpdated();
      this.pdfWriter.endFile();
      return this.basePdfDocument.transport.getData().then(function(data) {
        var blob;
        blob = new Blob([data, _this.pdfWriter.out.getArray()], {
          type: "application/pdf"
        });
        return URL.createObjectURL(blob);
      });
    }
  };

  PdfDict = function(obj, topDict, ref, manager) {
    this.topDict = topDict != null ? topDict : this;
    this.ref = ref;
    this.manager = manager;
    this.map = obj.map;
  };

  PdfDict.prototype = {
    update: function() {
      return this.topDict.manager.update(this.topDict.ref, this.topDict);
    },
    has: function(key) {
      return key in this.map;
    },
    getRaw: function(key) {
      return this.map[key];
    },
    getPromise: function(key) {
      var subObj;
      if (!(key in this.map)) {
        return Promise.reject(new Error("Key not found."));
      }
      subObj = this.map[key];
      if (isRef(subObj)) {
        return this.topDict.manager.getPromise(subObj);
      }
      if (isDict(subObj)) {
        return Promise.resolve(new PdfDict(subObj, this));
      }
      return Promise.resolve(subObj);
    },
    set: function(key, val) {
      var newObj, subObj;
      subObj = this.map[key];
      if (isRef(subObj)) {
        newObj = new PdfDict(val, null, subObj, this.topDict.manager);
        newObj.update();
        return this;
      } else {
        this.map[key] = val;
        this.update();
        return this;
      }
    }
  };

  PdfWriter = function() {
    this.out = new Buffer();
    this.globalOffset = 0;
    this.nextNum = 1;
    this.offsets = {};
    this.trailer = null;
    this.startXRef = 0;
  };

  PdfWriter.prototype = {
    createRef: function() {
      return {
        num: this.nextNum++,
        gen: 0
      };
    },
    write: function(str) {
      return this.out.writeStringLatin1(str);
    },
    writeArray: function(array) {
      return this.out.writeArray(array);
    },
    writeObj: function(ref, obj, stream) {
      this.offsets[genObjId(ref)] = {
        num: ref.num,
        gen: ref.gen,
        free: false,
        offset: this.out.length + this.globalOffset
      };
      this.write("" + ref.num + " " + ref.gen + " obj\n" + (serialize(obj)) + "\n");
      if (stream != null) {
        this.write("stream\n");
        this.writeArray(stream);
        this.write("\nendstream\n");
      }
      return this.write("endobj\n");
    },
    endFile: function() {
      var _ref;
      if (((_ref = this.trailer.map.Type) != null ? _ref.name : void 0) === "XRef") {
        console.log("Writing XRefStream.");
        return this.writeXRefStream();
      } else {
        console.log("Writing XRefTable.");
        return this.writeXRefTable();
      }
    },
    writeXRefStream: function() {
      var W, entry, g, groups, key, obj, objRef, stream, val, _i, _j, _len, _len1, _ref;
      stream = new Buffer();
      W = [1, 4, 2];
      obj = {
        map: {
          Type: {
            name: "XRef"
          },
          Index: [],
          W: W
        }
      };
      objRef = this.createRef();
      _ref = this.trailer.map;
      for (key in _ref) {
        val = _ref[key];
        if (key !== "Type" && key !== "Index" && key !== "W" && key !== "Filter" && key !== "DecodeParms") {
          obj.map[key] = val;
        }
      }
      groups = group(values(this.offsets), function(a, b) {
        return a.num - b.num;
      }, function(v, group) {
        return group[group.length - 1].num + 1 === v.num;
      });
      for (_i = 0, _len = groups.length; _i < _len; _i++) {
        g = groups[_i];
        obj.map.Index.push(g[0].num, g.length);
        for (_j = 0, _len1 = g.length; _j < _len1; _j++) {
          entry = g[_j];
          if (entry.free) {
            stream.writeNumBigEndian(0, W[0]);
            stream.writeNumBigEndian(entry.num, W[1]);
            stream.writeNumBigEndian(entry.gen, W[2]);
          } else {
            stream.writeNumBigEndian(1, W[0]);
            stream.writeNumBigEndian(entry.offset, W[1]);
            stream.writeNumBigEndian(entry.gen, W[2]);
          }
        }
      }
      obj.map.Size = this.nextNum;
      obj.map.Length = stream.getByteLength();
      this.startXRef = this.out.length + this.globalOffset;
      this.writeObj(objRef, obj, stream);
      this.write("startxref\n" + this.startXRef + "\n");
      return this.write("%%EOF\n");
    },
    writeXRefTable: function() {
      var entry, g, groups, res, _i, _j, _len, _len1;
      res = "";
      groups = group(values(this.offsets), function(a, b) {
        return a.num - b.num;
      }, function(v, group) {
        return group[group.length - 1].num + 1 === v.num;
      });
      for (_i = 0, _len = groups.length; _i < _len; _i++) {
        g = groups[_i];
        res += "" + g[0].num + " " + g.length + "\n";
        for (_j = 0, _len1 = g.length; _j < _len1; _j++) {
          entry = g[_j];
          res += ("" + (pad(entry.offset, 10)) + " " + (pad(entry.gen, 5))) + (" " + (entry.free ? "f" : "n") + "\n");
        }
      }
      this.startXRef = this.out.length + this.globalOffset;
      this.write("xref\n");
      this.write(res);
      this.trailer.map.Size = this.nextNum;
      this.write("trailer\n");
      this.write(serialize(this.trailer));
      this.write("startxref\n" + this.startXRef + "\n");
      return this.write("%%EOF\n");
    }
  };

  serialize = function(obj) {
    var k, v, _ref;
    if (((_ref = typeof obj) === "boolean" || _ref === "number") || obj === null) {
      return "" + obj;
    }
    if (typeof obj === "string") {
      if (/[()\\\r]/.test(obj)) {
        return "<" + (toHex(obj)) + ">";
      } else {
        return "(" + obj + ")";
      }
    }
    if (typeof obj !== "object") {
      throw new Error("Cannot serialize.");
    }
    if ("name" in obj) {
      return "/" + obj.name;
    }
    if (obj.hasOwnProperty("map")) {
      return "<<\n" + (((function() {
        var _ref1, _results;
        _ref1 = obj.map;
        _results = [];
        for (k in _ref1) {
          v = _ref1[k];
          _results.push("/" + k + " " + (serialize(v)));
        }
        return _results;
      })()).join("\n")) + "\n>>";
    }
    if (obj instanceof Array) {
      return "[ " + (((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = obj.length; _i < _len; _i++) {
          v = obj[_i];
          _results.push(serialize(v));
        }
        return _results;
      })()).join(" ")) + "]";
    }
    if ("dict" in obj) {
      return new Error("Cannot serialize streams yet.");
    }
    if ("num" in obj) {
      return "" + obj.num + " " + obj.gen + " R";
    }
    throw new Error("Cannot serialize.");
  };

  window.Promise.prototype["in"] = function(varName) {
    return this.then(function(data) {
      return window[varName] = data;
    })["catch"](function(error) {
      return window[varName] = {
        PromiseRejected: error
      };
    });
  };

  window.openArray = function(array) {
    return window.open(getBlob(array));
  };

  window.getBlob = getBlob = function(array) {
    var blob;
    blob = new Blob([array]);
    return window.URL.createObjectURL(blob);
  };

  window.addEventListener("load", function() {
    var div;
    div = document.createElement("div");
    div.style.position = "fixed";
    div.style.top = "35px";
    div.style.right = "20px";
    div.style.width = "100px";
    div.style.height = "100px";
    div.style.background = "white";
    div.style.padding = "5px";
    div.style.boxShadow = "1px 3px 5px black";
    document.body.appendChild(div);
    div.innerHTML = "<a href='javascript:deleteFirstPage();void(0)'>Delete first page!</a>";
    return window.outputDiv = div;
  });

  window.deleteFirstPage = function() {
    var pdf;
    window.pdfManager = pdf = new PdfObjectManager();
    return new function() {
      var findFirst,
        _this = this;
      return pdf.setBaseDocumentPromise(PDFView.pdfDocument).then(function() {
        return pdf.getTrailerPromise();
      }).then(function(trailer) {
        return trailer.getPromise("Root");
      }).then(function(root) {
        console.log(root);
        return root.getPromise("Pages");
      }).then(findFirst = function(pages) {
        if (isDict(pages) && pages.has("Kids")) {
          _this.lastPages = pages;
          _this.lastPages.set("Count", _this.lastPages.map.Count - 1);
          return pages.getPromise("Kids").then(findFirst);
        }
        if (isArray(pages)) {
          _this.lastPagesArray = pages;
          return pdf.getPromise(pages[0]).then(findFirst);
        } else {
          return {
            lastPages: _this.lastPages,
            lastPagesArray: _this.lastPagesArray
          };
        }
      }).then(function(res) {
        res.lastPagesArray.shift();
        res.lastPages.set("Kids", res.lastPagesArray);
        return console.log(res);
      }).then(function() {
        return pdf.createObjectURLPromise();
      }).then(function(url) {
        return window.outputDiv.innerHTML += " <a href='" + url + "'>Generated PDF</a>";
      })["catch"](function(err) {
        return window.outputDiv.innerHTML += " ERROR: " + err;
      });
    };
  };

}).call(this);
